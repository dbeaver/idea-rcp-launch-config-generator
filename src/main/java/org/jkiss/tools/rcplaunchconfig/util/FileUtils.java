/*
 * DBeaver - Universal Database Manager
 * Copyright (C) 2010-2024 DBeaver Corp and others
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jkiss.tools.rcplaunchconfig.util;

import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FileUtils {

    private static final Logger log = LoggerFactory.getLogger(FileUtils.class);

    private static final String NAME_AND_VERSION_SEPARATOR = "_";

    private static final Map<File, File[]> folderContents = new HashMap<>();
    public static final Set<String> preferOlderBundles = Set.of(
//        "com.google.guava",
        "jakarta.servlet-api"
    );


    @Nullable
    public static File findFirstChildByPackageName(@Nonnull Path folder, @Nonnull String packageName) {
        var folderFile = folder.toFile();
        if (!folderFile.exists()) {
            log.error("Cannot find '{}'", folder);
            return null;
        }
        return findFirstChildByPackageName(folderFile, packageName);
    }

    @Nullable
    public static File findFirstChildByPackageName(@Nonnull File folder, @Nonnull String packageName) {
        File[] fileList = folderContents.get(folder);
        if (fileList == null) {
            fileList = folder.listFiles();
            if (fileList == null) {
                return null;
            }
            folderContents.put(folder, fileList);
        }
        List<File> files = new ArrayList<>();
        for (File file : fileList) {
            String name = file.getName();
            var candidatePackageName = name;
            int divPos = candidatePackageName.lastIndexOf(NAME_AND_VERSION_SEPARATOR);
            if (divPos != -1 && Character.isDigit(candidatePackageName.charAt(divPos + 1))) {
                candidatePackageName = StringUtils.substringBeforeLast(name, NAME_AND_VERSION_SEPARATOR);
            }
            if (packageName.equals(candidatePackageName)) {
                files.add(file);
            }
        }
        if (files.isEmpty()) {
            return null;
        } else if (files.size() > 1) {
            return getMaxVersion(files.toArray(new File[0]), packageName);
        }
        return files.get(0);
    }

    private static File getMaxVersion(@Nonnull File[] files, @Nonnull String packageName) {
        var filesByVersions = Arrays.stream(files)
            .collect(Collectors.toMap(FileUtils::extractVersion, it -> it));

        BundleVersion properVersion;
        Stream<BundleVersion> bundleStream = filesByVersions.keySet().stream();
        if (preferOlderBundles.contains(packageName)) {
            properVersion = bundleStream.min(BundleVersion::compareTo).orElseThrow();
        } else {
            properVersion = bundleStream.max(BundleVersion::compareTo).orElseThrow();
        }
        var result = filesByVersions.get(properVersion);

        var candidatesNamesList = Arrays.stream(files)
            .map(File::getName)
            .collect(Collectors.joining("\n  "));
        log.debug(
            "Multiple '{}' versions was found. '{}' will be used. Full candidates list:\n  {}",
            packageName,
            result.getName(),
            candidatesNamesList
        );

        return result;
    }

    private static @Nonnull BundleVersion extractVersion(@Nonnull File file) {
        return new BundleVersion(StringUtils.substringAfterLast(file.getName(), NAME_AND_VERSION_SEPARATOR));
    }

    public static @Nonnull Properties readPropertiesFile(@Nonnull Path path) throws IOException {
        Properties result = new Properties();
        try (var in = Files.newBufferedReader(path)) {
            result.load(in);
        }
        return result;
    }

    public static void writePropertiesFile(@Nonnull Path path, @Nonnull Map<String, String> properties)
        throws IOException {
        try (var out = Files.newBufferedWriter(path, StandardOpenOption.CREATE_NEW)) {
            storeProperties(out, "Generated by eclipse-plugins-resolver", properties);
        }
    }

    public static void storeProperties(BufferedWriter bw, String comments, @Nonnull Map<String, String> properties) {
        try {
            if (comments != null) {
                bw.write("#" + comments);
            }
            bw.write("#" + new Date());
            bw.newLine();
            for (Map.Entry<String, String> e : properties.entrySet()) {
                String key = e.getKey();
                String val = e.getValue();
                bw.write(key + "=" + val);
                bw.newLine();
            }
            bw.flush();
        } catch (IOException e) {
            System.err.println(e);
        }
    }

    public static boolean exists(@Nonnull Path path) {
        return path.toFile().exists();
    }

    public static void removeAllFromDir(@Nonnull Path targetPath) throws IOException {
        if (targetPath.toFile().exists()) {
            Files.walkFileTree(targetPath,
                new SimpleFileVisitor<>() {
                    @Override
                    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                        if (exc != null) {
                            throw exc;
                        }
                        if (!targetPath.equals(dir)) {
                            Files.delete(dir);
                        }
                        return FileVisitResult.CONTINUE;
                    }

                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (!targetPath.equals(file)) {
                            Files.delete(file);
                        }
                        return FileVisitResult.CONTINUE;
                    }
                });
        } else {
            var resultPathFile = targetPath.toFile();
            if (!resultPathFile.exists() && !resultPathFile.mkdirs()) {
                throw new IllegalStateException("Failed to create dirs: '" + targetPath + "'");
            }
        }
    }
}


